# 重塑矩阵
## 内容
在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。 重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。 如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

示例 1：
```bash
输入：mat = [[1,2],[3,4]], r = 1, c = 4
输出：[[1,2,3,4]]
```
示例 2：

```bash
输入：mat = [[1,2],[3,4]], r = 2, c = 4
输出：[[1,2],[3,4]]
```

## 思路

### 思路一: 双指针法
先判断矩阵是否能重构，`m*n == r*c`。 接着设置 outs 位重构矩阵，line 为重构矩阵的当前行，lineIndex 为 line 的下标指针。遍历源矩阵，将每个元素填入 line，并累加 lineIndex，如果 lineIndex 的长度为 c (重构矩阵的列数)，说明已填充完重构矩阵的改行。清空 line 和 lineIndex，继续填充，直到结束。

复杂度分析:
- 时间复杂度: 遍历原矩阵(二维数组) O(m*n)
- 空间复杂度: O(1)，不考虑输出数组

### 思路二：取模法
整体思路和思路一一致，但是在重构新矩阵时可以用到一个特性，一维矩阵对应二维矩阵 `nums[i] == mat[i/n][i%m]`。

复杂度分析:
- 时间复杂度: 遍历原矩阵(二维数组) O(m*n)
- 空间复杂度: O(1)，不考虑输出数组

#  杨辉三角
## 内容
给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。 在「杨辉三角」中，每个数是它左上方和右上方的数的和。

示例 1:
```bash
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

示例 2:
```bash
输入: numRows = 1
输出: [[1]]
```

## 思路
简单根据杨辉三角的定义，直接遍历生成即可

复杂度分析：
- 时间复杂度: 嵌套循环 O(numRows^2)
- 空间复杂度: O(1)，不考虑输出数组